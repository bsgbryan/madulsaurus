"use strict";(self.webpackChunkmadulsaurus=self.webpackChunkmadulsaurus||[]).push([[185],{4561:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var s=t(5893),i=t(1151);const o={sidebar_position:1,title:"Star Map (Overview)",custom_edit_url:null},r=void 0,a={id:"star-map",title:"Star Map (Overview)",description:"What is M\xe4d\u016bl?",source:"@site/docs/star-map.md",sourceDirName:".",slug:"/star-map",permalink:"/docs/star-map",draft:!1,unlisted:!1,editUrl:null,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Star Map (Overview)",custom_edit_url:null},sidebar:"tutorialSidebar",next:{title:"Padawan (Getting Started)",permalink:"/docs/padawan"}},l={},c=[{value:"What is M\xe4d\u016bl?",id:"what-is-m\xe4d\u016bl",level:2},{value:"Why functional?",id:"why-functional",level:3},{value:"Goals",id:"goals",level:2},{value:"Fun testing",id:"fun-testing",level:3},{value:"The problem",id:"the-problem",level:4},{value:"The context",id:"the-context",level:4},{value:"The solution",id:"the-solution",level:4},{value:"Everything&#39;s opt-in",id:"everythings-opt-in",level:3},{value:"Super powers",id:"super-powers",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"what-is-m\xe4d\u016bl",children:"What is M\xe4d\u016bl?"}),"\n",(0,s.jsx)(n.p,{children:"M\xe4d\u016bl is a set of conventions and tools that support crafting rock-solid, functional code."}),"\n",(0,s.jsx)(n.h3,{id:"why-functional",children:"Why functional?"}),"\n",(0,s.jsx)(n.p,{children:"Functional programming is a declarative programming paradigm where programs are created by applying sequential functions rather than statements."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Easy debugging"}),": Pure functions and immutable data make it easy to find where variable values are set. Pure functions have fewer factors influencing them and therefore allow you to find the bugged section easier."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Lazy evaluation"}),": Functional programs only evaluate computations at the moment they\u2019re needed. This allows the program to reuse results from previous computations and save runtime."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Modular"}),": Pure functions do not rely on external variables or states to function, meaning they\u2019re easily reused across the program. Also, functions will only complete a single operation or computation to ensure you can reuse that function without accidentally importing extra code."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Enhanced readability"}),": Functional programs are easy to read because the behavior of each function is immutable and isolated from the program\u2019s state. As a result, you can predict what each function will do often just by the name!"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Parallel programming"}),": It\u2019s easier to create parallel programs with a functional programming approach because immutable variables reduce the amount of change within the program. Each function only has to deal with user input and can trust that the program state will remain mostly the same!"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.em,{children:["Read more at ",(0,s.jsx)(n.a,{href:"https://www.educative.io/blog/what-is-functional-programming-python-js-java#what",children:"educative.io"})]})}),"\n",(0,s.jsx)(n.h2,{id:"goals",children:"Goals"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Make testing so easy it's fun"}),"\n",(0,s.jsx)(n.li,{children:"Everything is opt-in"}),"\n",(0,s.jsx)(n.li,{children:"Defining and using maduls is so simple it feels like cheating"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"fun-testing",children:"Fun testing"}),"\n",(0,s.jsx)(n.p,{children:"Testing our code is essential, we all know that."}),"\n",(0,s.jsx)(n.h4,{id:"the-problem",children:"The problem"}),"\n",(0,s.jsxs)(n.p,{children:["Testing out code can be a major pain; often, the more crucial the tests are, the more painful they are to write. Why is this? Because of ",(0,s.jsx)(n.a,{href:"https://stackoverflow.com/a/14081911/3803332",children:"mocking/stubbing"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"the-context",children:"The context"}),"\n",(0,s.jsxs)(n.p,{children:["Tools like Jest work very hard to make defining and executing mocks/stubs as straightforward as possible. There's only so much they can do, though, as mocking/stubbing is inherently cumbersome and unwieldy. To successfully mock/stub a dependency, its import must be intercepted/replaced - but not just once; it often must be intercepted many times, for different reasons and with different outcomes. And then, other times, we need the dependency to ",(0,s.jsx)(n.em,{children:"not"})," be interecpted! It can get confusing fast - and to compound things, when defining each instance of a mock/stub, we need to be ",(0,s.jsx)(n.em,{children:"extremely"})," specific. If we're even a little bit off in the setup of our mocks/stubs, our tests will fail in ways that can be extremely difficult to debug."]}),"\n",(0,s.jsx)(n.h4,{id:"the-solution",children:"The solution"}),"\n",(0,s.jsxs)(n.p,{children:["M\xe4d\u016bl eliminates the need to use mocking/stubbing tools like ",(0,s.jsx)(n.code,{children:"jest.spyOn"})," and ",(0,s.jsx)(n.code,{children:"jest.mock"})," by passing everything a function needs to do its work (dependencies as well as input) as parameters. In tests, then, we simply pass functions that do what we want for our test in place of the functions used when the code runs in production."]}),"\n",(0,s.jsx)(n.p,{children:"As an example, consider the M\xe4d\u016bl below:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'title="src/EventQueue.ts"',children:"export const dependencies = () => ({\n  '+Queue': ['pop']\n})\n\nexport const next = ({ handler, pop }) => {\n  handler({ event: pop() })\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This M\xe4d\u016bl declares a single dependency, and exports one function that uses that dependency. A test for ",(0,s.jsx)(n.code,{children:"next"})," could look something like:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'title="test/EventQueue.test.ts"',children:"import { next } from \"../src/EventQueue\"\n\ndescribe('next', () => {\n  it('calls pop to get the next item from the Queue, and passes that to the specified handler', () => {\n    const called = {\n      pop:     false,\n      handler: false,\n    }\n\n    const pop = () = {\n      called.pop = true\n      return 'handle me'\n    }\n\n    let passed = ''\n\n    const handler: thing => {\n        passed = thing\n        called.handler = true\n      }\n    }\n\n    next({ handler, pop })\n\n    expect(called.pop).toBeTruthy()\n    expect(called.handler).toBeTruthy()\n\n    expect(passed).toEqual({ event: 'handle me' })\n  })\n})\n"})}),"\n",(0,s.jsx)(n.admonition,{title:"Regarding type definitions",type:"note",children:(0,s.jsx)(n.p,{children:"The example code on this page does not include type definitions. This is done for brevity and to keep focus on the structure and organisation of the code."})}),"\n",(0,s.jsxs)(n.p,{children:["Look Ma, no ",(0,s.jsx)(n.code,{children:"jest"}),"! \ud83d\ude4c\ud83c\udffb"]}),"\n",(0,s.jsx)(n.h3,{id:"everythings-opt-in",children:"Everything's opt-in"}),"\n",(0,s.jsx)(n.p,{children:"M\xe4d\u016bl can:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Define, import, initialize, and pass dependencies to your exported functions"}),"\n",(0,s.jsxs)(n.li,{children:["Define, import, initiaize, and execute decorators (functions that run before and/or after your ",(0,s.jsx)(n.code,{children:"async"})," exported functions)"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["All of this is opt-in. You can mix & match traditional ",(0,s.jsx)(n.code,{children:"import"})," statements with the ",(0,s.jsx)(n.code,{children:"dependencies"})," function however works best for you. Only what you specify via the ",(0,s.jsx)(n.code,{children:"decorators"})," function are executed around your code. Functions whose input does not extend M\xe4d\u016bl's ",(0,s.jsx)(n.code,{children:"SyncInput"})," or ",(0,s.jsx)(n.code,{children:"AsyncInput"})," interfaces are not wrapped or processed in any way."]}),"\n",(0,s.jsx)(n.h3,{id:"super-powers",children:"Super powers"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'title="MessageManager.ts"',children:"export const dependencies = () => ({\n  '+API': ['get', 'post']\n})\n\nexport const decorators = () => ({\n  fetch: {\n    before: {\n      '+Auth': ['validatePermisisons'],\n      '+API':  ['validateInput'],\n    },\n    after: {\n      '+API':      ['handleErrors'],\n      '+Settings': ['applyContentFilters'],\n    },\n  },\n  send: {\n    before: {\n      '+Auth':      ['validatePermisisons'],\n      '+API':       ['validateInput'],\n      '+Moderator': ['filterExplicitContent'],\n    },\n    after: {\n      '+API': ['handleErrors'],\n    },\n  },\n})\n\nexport const fetch = async ({ channel, get  }) => await get ({ channel })\nexport const send  = async ({ content, post }) => await post({ content })\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In the above M\xe4d\u016bl, the ",(0,s.jsx)(n.code,{children:"decorators"})," ensure that:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.em,{children:["Every call to ",(0,s.jsx)(n.code,{children:"fetch"})," is authenticated and authorized"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.em,{children:["Every call to ",(0,s.jsx)(n.code,{children:"fetch"})," runs the message contents through the user's configured filters"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.em,{children:["Every call to ",(0,s.jsx)(n.code,{children:"fetch"})," is wrapped in input validation and error handling logic"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.em,{children:["Every call to ",(0,s.jsx)(n.code,{children:"send"})," is authenticated and authorized"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.em,{children:["Every call to ",(0,s.jsx)(n.code,{children:"send"})," runs the message contents through ",(0,s.jsx)(n.code,{children:"filterExplicitContent"})]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.em,{children:["Every call to ",(0,s.jsx)(n.code,{children:"send"})," is wrapped with API input and error processing behavior."]})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The functions MessageManager exports don't have to worry about or duplicate any of the behvaior implemented by the ",(0,s.jsx)(n.code,{children:"decorators"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["It's also extremely clear what happens on every invokation of ",(0,s.jsx)(n.code,{children:"fetch"})," and ",(0,s.jsx)(n.code,{children:"send"}),"; anyone working with this M\xe4d\u016bl can see everything that's going on."]})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>r});var s=t(7294);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);